use crate::calc_ast::{Operator, Type};
grammar;

pub ExprLine: (u64, Type) = {
    <e:expr> "->" <t:convTo> => {
        let ret = match t {
            Type::Decimal => {
                e
            },
            Type::Hex => {
                e
            },
            Type::Binary => {
                e
            }
        };
        (e, t)
    },
}

expr: u64 = {
    <e1:expr> <o:op> <e2:term> => {
        match o {
            Operator::Add => e1 + e2,
            Operator::Subtract => e1 - e2,
        }
    },
    <n:term> => n,
}

term: u64 = {
    <d:d64> => d,
    <x:x64> => x,
    <b:b64> => b,
}

convTo: Type = {
    "d" => Type::Decimal,
    "x" => Type::Hex,
    "b" => Type::Binary,
}

op: Operator = {
    "+" => Operator::Add,
    "-" => Operator::Subtract,
}

d64: u64 = {
    <s:r"-[0-9]+"> => {
        let ret = i64::from_str_radix(s, 10).expect("Invalid decimal integer");
        ret as u64
    },
    <s:r"[0-9]+"> => {
        u64::from_str_radix(s, 10).expect("Invalid decimal integer")
    },
}

x64: u64 = {
    <s:r"0x[0-9a-fA-F]+"> => {
        u64::from_str_radix(&s[2..], 16).expect("Invalid hex")
    },
}

b64: u64 = {
    <s:r"0b[0-1]+"> => {
        u64::from_str_radix(&s[2..], 2).expect("Invalid binary")
    }
}